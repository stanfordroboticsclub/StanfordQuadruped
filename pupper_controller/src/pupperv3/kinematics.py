from dataclasses import dataclass
import time
import numpy as np
from numpy import sin, cos
from numba import njit


@dataclass
class LegConfig:
    motor_x: float  # x-axis measure of motor to motor distance
    motor_y: float  # y-axis measure of motor to motor distance
    abduction_offset: float  # abduction offset (in +Ny>)
    link_2_x: float  # component of Bo_r_Co vector in -Bx> direction
    link_2_z: float  # component of Bo_r_Co vector in -Bz> direction
    link_3: float  # length (+) of lower leg


@njit(cache=True)
def leg_fk(
    qA: float,
    qB: float,
    qC: float,
    motor_x: float,
    motor_y: float,
    abduction_offset: float,
    link_2_x: float,
    link_2_z: float,
    link_3: float,
):
    """Only works for right-sided legs"""
    MX = motor_x
    MY = motor_y
    LA = abduction_offset
    LX = link_2_x
    LZ = link_2_z
    L3 = link_3

    sA = sin(qA)
    cA = cos(qA)
    sB = sin(qB)
    cB = cos(qB)
    sC = sin(qC)
    cC = cos(qC)

    # Generated by MotionGenesis, use precomputed sin/cos
    Fx = MX - LX * cA - LZ * sA * cB - L3 * (sC * cA + sA * cB * cC)
    Fy = LZ * sB + L3 * sB * cC + LA + MY
    Fz = LX * sA + L3 * (sA * sC - cA * cB * cC) - LZ * cA * cB
    return np.array((Fx, Fy, Fz))


@njit(cache=True)
def leg_jacobian(
    qA: float,
    qB: float,
    qC: float,
    link_2_x: float,
    link_2_z: float,
    link_3: float,
):
    result = np.zeros((3, 3))
    LX = link_2_x
    LZ = link_2_z
    L3 = link_3
    sA = sin(qA)
    cA = cos(qA)
    sB = sin(qB)
    cB = cos(qB)
    sC = sin(qC)
    cC = cos(qC)

    # Generated by MotionGenesis, converted to 0-indexing, use precomputed sin/cos
    result[0, 0] = LX * sA + L3 * (sA * sC - cA * cB * cC) - LZ * cA * cB
    result[0, 1] = sA * sB * (LZ + L3 * cC)
    result[0, 2] = -L3 * (cA * cC - sA * sC * cB)
    result[1, 0] = 0
    result[1, 1] = cB * (LZ + L3 * cC)
    result[1, 2] = -L3 * sB * sC
    result[2, 0] = LX * cA + LZ * sA * cB + L3 * (sC * cA + sA * cB * cC)
    result[2, 1] = sB * cA * (LZ + L3 * cC)
    result[2, 2] = L3 * (sA * cC + sC * cA * cB)

    return result


@njit(cache=True)
def leg_ik(
    center_to_foot_vector: np.ndarray,
    motor_x: float,
    motor_y: float,
    abduction_offset: float,
    link_2_x: float,
    link_2_z: float,
    link_3: float,
    initial_guess=None,
    alpha=1.0,
):
    """Use newton's method.

    With a good guess it takes about 4 iterations or 0.0002s to converge"""

    # Use initial guess for joint angles if provided
    guess = np.zeros(3) if initial_guess is None else initial_guess

    for i in range(20):
        matrix = np.linalg.inv(
            leg_jacobian(guess[0], guess[1], guess[2], link_2_x, link_2_z, link_3)
        )
        error = (
            leg_fk(
                guess[0],
                guess[1],
                guess[2],
                motor_x,
                motor_y,
                abduction_offset,
                link_2_x,
                link_2_z,
                link_3,
            )
            - center_to_foot_vector
        )
        step = -alpha * matrix @ error

        # prevent big solver steps
        guess += np.clip(step, -1, 1)
        if np.linalg.norm(error) < 1e-6:
            break
    # print("Took {} iterations to converge".format(i))
    # constrain to -pi to pi
    guess = np.fmod(guess + np.pi, 2 * np.pi) - np.pi
    return guess


# @njit
def four_legs_inverse_kinematics(r_body_foot, config, initial_guess=None):
    """Find the joint angles for all twelve DOF correspoinding to the given matrix of body-relative foot positions.

    Parameters
    ----------
    r_body_foot : numpy array (3,4)
        Matrix of the body-frame foot positions. Each column corresponds to a separate foot.
    config : Config object
        Object of robot configuration parameters.
    initial_guess

    Returns
    -------
    numpy array (3,4)
        Matrix of corresponding joint angles.
    """
    alpha = np.zeros((3, 4))

    initial_guess = np.zeros((3, 4))
    initial_guess *= config.MOTOR_DIRECTIONS

    for i in range(4):
        leg_config = LegConfig(
            motor_x=config.LEG_ORIGINS[0, i],
            motor_y=config.LEG_ORIGINS[1, i],
            abduction_offset=config.ABDUCTION_OFFSETS[i],
            link_2_x=0.07,
            link_2_z=0.07,
            link_3=config.LEG_L2,
        )
        alpha[:, i] = leg_ik(
            r_body_foot[:, i],
            motor_x=leg_config.motor_x,
            motor_y=leg_config.motor_y,
            abduction_offset=leg_config.abduction_offset,
            link_2_x=leg_config.link_2_x,
            link_2_z=leg_config.link_2_z,
            link_3=leg_config.link_3,
            initial_guess=initial_guess[:, i],
        )
        # FK model treats shank vertical as zero angle while
        # simulator and real robot use 30 deg angle
        alpha[2, i] += np.radians(30)

    alpha *= config.MOTOR_DIRECTIONS
    return alpha


if __name__ == "__main__":
    leg_config = LegConfig(
        motor_x=0.2,
        motor_y=0.2,
        abduction_offset=-0.05,
        link_2_x=0.05,
        link_2_z=0.05,
        link_3=0.1,
    )

    # q0 = (0, 0.5, 0.5)
    q0 = np.random.randn(3)
    print("q0: ", q0)
    r = leg_fk(
        *q0,
        motor_x=leg_config.motor_x,
        motor_y=leg_config.motor_y,
        abduction_offset=leg_config.abduction_offset,
        link_2_x=leg_config.link_2_x,
        link_2_z=leg_config.link_2_z,
        link_3=leg_config.link_3,
    )
    print("r: ", r)
    start_jit = time.time()
    q = leg_ik(
        r,
        motor_x=leg_config.motor_x,
        motor_y=leg_config.motor_y,
        abduction_offset=leg_config.abduction_offset,
        link_2_x=leg_config.link_2_x,
        link_2_z=leg_config.link_2_z,
        link_3=leg_config.link_3,
    )
    end_jit = time.time()
    print("\nJIT took: ", (end_jit - start_jit), "s")

    start = time.time()
    for i in range(10000):
        q = leg_ik(
            r + np.random.randn(3) * 0.00001,
            motor_x=leg_config.motor_x,
            motor_y=leg_config.motor_y,
            abduction_offset=leg_config.abduction_offset,
            link_2_x=leg_config.link_2_x,
            link_2_z=leg_config.link_2_z,
            link_3=leg_config.link_3,
        )
    end = time.time()
    # 0.01 ms with full IK JIT, about 0.15 (0.1 - 0.36) ms with JIT. 0.18 - 0.6 ms without JIT
    print("IK took: ", (end - start) / 10, " ms\n")
    print("q: ", q)
    r2 = leg_fk(
        *q,
        leg_config.motor_x,
        leg_config.motor_y,
        leg_config.abduction_offset,
        leg_config.link_2_x,
        leg_config.link_2_z,
        leg_config.link_3,
    )
    print("r2: ", r)

    print(
        leg_jacobian(
            0, 0, 0, leg_config.link_2_x, leg_config.link_2_z, leg_config.link_3
        )
    )

    four_legs_r = np.array([[0, 0, 0, 0], [0, 0, 0, 0], [-0.1, -0.1, -0.1, -0.1]])
    from pupper_controller.src.pupperv3 import config

    config = config.Config()
    start = time.time()
    alpha = four_legs_inverse_kinematics(four_legs_r, config)
    end = time.time()
    print("\nInitial 4 legs IK took: ", (end - start), " s\n")

    start = time.time()
    for i in range(1000):
        alpha = four_legs_inverse_kinematics(four_legs_r, config) + i * 1e-6
    end = time.time()
    print("\n4 legs IK took: ", (end - start), " ms\n")
    print("r: ", four_legs_r)
    print("alpha: ", alpha)
